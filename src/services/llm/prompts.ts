// LLM Prompts for content generation

/** AI-recommended BGM from script generation */
export interface BgmRecommendation {
  /** Ideal BGM description generated by AI */
  description: string;
  /** One of the preset BGM IDs: piano, tragic, gentle, calm, epic, mystery, cheerful, thinking */
  presetId: string;
}

export interface SpecAnalysisResult {
  storyTitle: string;
  subtitle?: string;
  targetAudience: string;
  formatAndDuration: string;
  toneAndExpression: string;
  addBgm: boolean;
  addSoundEffects: boolean;
  hasVisualContent: boolean;
}

export interface ScriptGenerationConfig {
  title: string;
  targetAudience: string;
  formatAndDuration: string;
  toneAndExpression: string;
  addBgm: boolean;
  addSoundEffects: boolean;
  hasVisualContent: boolean;
  // Optional template hints for better script generation
  styleHint?: string;
  structureHint?: string;
  voiceDirectionHint?: string;
}

export interface SpecAnalysisConfig {
  templateName?: string;
  targetAudience?: string;
  formatAndDuration?: string;
  toneAndExpression?: string;
}

export function buildSpecAnalysisPrompt(content: string, config?: SpecAnalysisConfig): string {
  const contextSection = config && (config.templateName || config.targetAudience) 
    ? `
Project Context (use this to better understand what the user wants):
${config.templateName ? `- Template/Type: ${config.templateName}` : ''}
${config.targetAudience ? `- Target Audience: ${config.targetAudience}` : ''}
${config.formatAndDuration ? `- Format: ${config.formatAndDuration}` : ''}
${config.toneAndExpression ? `- Tone/Style: ${config.toneAndExpression}` : ''}
`
    : '';

  return `Analyze the following content and extract podcast/audio production specifications. Return a JSON object with these fields:
- storyTitle: The main title of the story/content (extract from content, considering the project context)
- subtitle: A short subtitle or tagline for the content (optional, can be empty)
- targetAudience: Who this content is for (e.g., "Students ages 11-15", "General audience")
- formatAndDuration: Format and estimated duration (e.g., "Audio podcast mp3, ~5 minutes")
- toneAndExpression: The tone and style (e.g., "Contemplative acoustic instrumental, himalayan-influenced")
- addBgm: boolean - whether background music is recommended
- addSoundEffects: boolean - whether sound effects are recommended
- hasVisualContent: boolean - whether visual content is requested
${contextSection}
Content to analyze:
${content}

Return ONLY the JSON object, no other text.`;
}

export function buildScriptGenerationPrompt(content: string, config: ScriptGenerationConfig): string {
  const visualInstruction = config.hasVisualContent 
    ? '\n  - coverImageDescription: visual description for this section'
    : '';

  const soundInstruction = config.addSoundEffects
    ? '\n  - soundMusic: short sound effect description (e.g. "Door creaking", "Thunder"). NOT background music. Empty if none.'
    : '';

  const bgmInstruction = config.addBgm
    ? `

Also include a top-level "bgmRecommendation" with:
- description: ideal BGM description (1-2 sentences, same language as content)
- presetId: one of [piano, tragic, gentle, calm, epic, mystery, cheerful, thinking]`
    : '';

  return `Convert this content into a structured podcast script.

RULES:
1. Lines must be ACTUAL SPOKEN CONTENT only — no titles, headers, stage directions, or annotations. Use those as section "name"/"description" instead.
2. Preserve original wording exactly. Do NOT rewrite, paraphrase, or expand contractions (keep "don't", "it's", etc.).
3. Include ALL lines, even repeated ones. Do NOT deduplicate or skip.
4. Keep continuous speech by the same speaker as ONE line. Only split on pause markers, tone shifts, or speaker changes.

Content: ${content}

Specs: Title: ${config.title} | Audience: ${config.targetAudience} | Format: ${config.formatAndDuration} | Tone: ${config.toneAndExpression} | BGM: ${config.addBgm ? 'Yes' : 'No'} | SFX: ${config.addSoundEffects ? 'Yes' : 'No'} | Visual: ${config.hasVisualContent ? 'Yes' : 'No'}

Return JSON ${config.addBgm ? '{ "sections": [...], "bgmRecommendation": {...} }' : 'array of sections'}. Each section:
- id, name (use source headers), description (incorporate tone/stage directions)${visualInstruction}
- timeline: [{ id, timeStart, timeEnd, lines: [{ speaker, line }]${soundInstruction} }]
${bgmInstruction}
Return ONLY valid JSON.`;
}

/**
 * Parse script generation response, handling both:
 * - Object format: { sections: [...], bgmRecommendation: {...} }
 * - Array format: [...]  (legacy, when addBgm is false)
 */
export function parseScriptGenerationResponse(text: string): {
  sections: unknown[];
  bgmRecommendation?: BgmRecommendation;
} {
  // Extract JSON from markdown code blocks or raw text
  const jsonMatch = text.match(/```(?:json)?\s*([\s\S]*?)```/);
  let jsonStr = jsonMatch ? (jsonMatch[1] || jsonMatch[0]).trim() : text.trim();

  // Try parsing as-is first
  let parsed: unknown;
  try {
    parsed = JSON.parse(jsonStr);
  } catch {
    // Fallback: try to find array or object pattern
    const objMatch = text.match(/\{[\s\S]*\}/);
    const arrMatch = text.match(/\[[\s\S]*\]/);
    jsonStr = (objMatch?.[0] || arrMatch?.[0] || jsonStr).trim();
    parsed = JSON.parse(jsonStr);
  }

  // Object format: { sections, bgmRecommendation }
  if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {
    const obj = parsed as Record<string, unknown>;
    if (Array.isArray(obj.sections)) {
      return {
        sections: obj.sections,
        bgmRecommendation: obj.bgmRecommendation as BgmRecommendation | undefined,
      };
    }
  }

  // Array format (legacy)
  if (Array.isArray(parsed)) {
    return { sections: parsed };
  }

  throw new Error('Invalid script generation response format');
}

/**
 * Character analysis result per character.
 */
export interface CharacterAnalysis {
  tags: string[];
  voiceDescription: string;
}

/**
 * Build a prompt to analyze characters from a generated script,
 * extracting tags and a TTS voice description for each character.
 * Returns a JSON object mapping character name → { tags, voiceDescription }.
 */
export function buildCharacterAnalysisPrompt(
  scriptJson: string,
  characterNames: string[],
  language: 'en' | 'zh' = 'en'
): string {
  const namesList = characterNames.map(n => `"${n}"`).join(', ');

  if (language === 'zh') {
    return `你是一个专业的配音导演。请根据以下脚本内容，分析每个Speaker角色的特征。

脚本内容（JSON 格式）:
${scriptJson}

需要分析的Speaker: [${namesList}]

为每个角色生成：
1. 2-4 个标签（tags），标签类型包括：
   - 性别（如：男性、女性）
   - 年龄段（如：儿童、青年、中年、老年）
   - 声音风格（如：温暖、低沉、活泼、严肃、专业、温柔）
   - 角色类型（如：主持人、旁白、嘉宾、叙述者）

2. 一段英文的声音描述（voiceDescription），约 50 个英文字符，用于 TTS 语音合成。必须用英文，包含以下方面：
   - Tone/Timbre/Pacing（如 "deep", "low-pitched", "speaks quickly", "smooth"）
   - Audio Quality（如 "studio-quality", "clear"）
   - Accent（如 "standard American accent", "British accent"）
   示例："Warm deep male voice, moderate pace, studio-quality, standard American accent"

以 JSON 对象格式返回，key 是角色名，value 是包含 tags 和 voiceDescription 的对象。示例：
{"主持人": {"tags": ["男性", "中年", "专业"], "voiceDescription": "Warm deep male voice, moderate pace, studio-quality"}, "嘉宾": {"tags": ["女性", "青年", "活泼"], "voiceDescription": "Bright young female voice, energetic pace, clear audio"}}

只输出 JSON，不要其他文字。`;
  }

  return `You are a professional voice director. Analyze the following podcast script and extract descriptive tags and a voice description for each character.

Script (JSON):
${scriptJson}

Characters to analyze: [${namesList}]

For each character, generate:
1. 2-4 tags. Tag categories include:
   - Gender (e.g. Male, Female)
   - Age group (e.g. Child, Young, Middle-aged, Elderly)
   - Voice style (e.g. Warm, Deep, Energetic, Serious, Professional, Gentle)
   - Role type (e.g. Host, Narrator, Guest, Storyteller)

2. A voiceDescription string (~50 characters, English only) for TTS voice synthesis. It should cover:
   - Tone/Timbre/Pacing (e.g. "deep", "low-pitched", "speaks quickly", "smooth")
   - Audio Quality (e.g. "studio-quality", "clear")
   - Accent (e.g. "standard American accent", "thick French accent")
   Example: "Warm deep male voice, moderate pace, studio-quality, standard American accent"

Return a JSON object where keys are character names and values are objects with "tags" and "voiceDescription". Example:
{"Host": {"tags": ["Male", "Middle-aged", "Professional"], "voiceDescription": "Warm deep male voice, moderate pace, studio-quality"}, "Guest": {"tags": ["Female", "Young", "Energetic"], "voiceDescription": "Bright young female voice, energetic pace, clear audio"}}

Return ONLY the JSON, no other text.`;
}
