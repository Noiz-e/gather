// LLM Prompts for content generation

/** AI-recommended BGM from script generation */
export interface BgmRecommendation {
  /** Ideal BGM description generated by AI */
  description: string;
  /** One of the preset BGM IDs: piano, tragic, gentle, calm, epic, mystery, cheerful, thinking */
  presetId: string;
}

export interface SpecAnalysisResult {
  storyTitle: string;
  subtitle?: string;
  targetAudience: string;
  formatAndDuration: string;
  toneAndExpression: string;
  addBgm: boolean;
  addSoundEffects: boolean;
  hasVisualContent: boolean;
}

export interface ScriptGenerationConfig {
  title: string;
  targetAudience: string;
  formatAndDuration: string;
  toneAndExpression: string;
  addBgm: boolean;
  addSoundEffects: boolean;
  hasVisualContent: boolean;
  // Optional template hints for better script generation
  styleHint?: string;
  structureHint?: string;
  voiceDirectionHint?: string;
}

export interface SpecAnalysisConfig {
  templateName?: string;
  targetAudience?: string;
  formatAndDuration?: string;
  toneAndExpression?: string;
}

export function buildSpecAnalysisPrompt(content: string, config?: SpecAnalysisConfig): string {
  const contextSection = config && (config.templateName || config.targetAudience) 
    ? `
Project Context (use this to better understand what the user wants):
${config.templateName ? `- Template/Type: ${config.templateName}` : ''}
${config.targetAudience ? `- Target Audience: ${config.targetAudience}` : ''}
${config.formatAndDuration ? `- Format: ${config.formatAndDuration}` : ''}
${config.toneAndExpression ? `- Tone/Style: ${config.toneAndExpression}` : ''}
`
    : '';

  return `Analyze the following content and extract podcast/audio production specifications. Return a JSON object with these fields:
- storyTitle: The main title of the story/content (extract from content, considering the project context)
- subtitle: A short subtitle or tagline for the content (optional, can be empty)
- targetAudience: Who this content is for (e.g., "Students ages 11-15", "General audience")
- formatAndDuration: Format and estimated duration (e.g., "Audio podcast mp3, ~5 minutes")
- toneAndExpression: The tone and style (e.g., "Contemplative acoustic instrumental, himalayan-influenced")
- addBgm: boolean - whether background music is recommended
- addSoundEffects: boolean - whether sound effects are recommended
- hasVisualContent: boolean - whether visual content is requested
${contextSection}
Content to analyze:
${content}

Return ONLY the JSON object, no other text.`;
}

export function buildScriptGenerationPrompt(content: string, config: ScriptGenerationConfig): string {
  const visualInstruction = config.hasVisualContent 
    ? 'Include a "coverImageDescription" field for each section describing the visual.'
    : '';
  
  // soundMusic is for sound effects ONLY — BGM is handled globally, not per-section
  const soundInstruction = config.addSoundEffects
    ? '  - soundMusic: sound effect instructions for this timeline item (short discrete sounds ONLY, e.g. "Door creaking open", "Thunder rumbling", "Birds chirping"). Do NOT put background music here — BGM is handled separately at the global level. Leave empty if no sound effect is needed for this item.'
    : '';

  // BGM recommendation instruction: ask AI to pick a preset and describe ideal BGM
  const bgmRecommendationInstruction = config.addBgm
    ? `

Additionally, recommend a background music for this content. Choose the BEST matching preset from the following list:
- piano: Elegant, soothing classical piano. Good for classical story themes.
- tragic: Music with a tragic, sorrowful tone. For melancholic or somber stories.
- gentle: Elegant, gentle music with a steady rhythm.
- calm: Very soothing music for relaxation and tranquility.
- epic: Grand, story-driven BGM with a slightly somber atmosphere. For significant events.
- mystery: Mysterious, building from calm to intense.
- cheerful: Upbeat music for cheerful, lighthearted topics.
- thinking: Subtle drumbeat with a mysterious tone that inspires reflection.

Include a "bgmRecommendation" field in the top-level JSON object with:
- description: A short ideal BGM description tailored to this specific content (1-2 sentences, in the SAME language as the content).
- presetId: The id of the best matching preset from the list above.`
    : '';

  return `Based on the following content and specifications, convert the content into a structured podcast script with multiple sections.

CRITICAL RULES:
1. Only include lines that are ACTUAL SPOKEN CONTENT — meaningful narrative or dialogue that a speaker would read aloud.
2. Do NOT include as lines:
   - Chapter titles, section headers, volume/chapter numbers (e.g. "Volume X - Chapter 3", "Pre-Chapter Audio")
   - Stage directions or performance notes (e.g. "[Tone: warm, conversational]", "[pause]", "[music fades in]")
   - Production metadata, timestamps, or annotations
   Instead, use these as context to inform the section "name", "description", or soundMusic fields.
3. Preserve the wording of actual dialogue/narrative lines exactly as they appear in the source. Do NOT rewrite, paraphrase, or summarize spoken content. Do NOT expand or change contracted forms (e.g., keep "don't" as "don't", "it's" as "it's", "I'm" as "I'm" — never expand them to "do not", "it is", "I am", etc.).
4. Include ALL lines from the source, even if they are repeated. Repetition is often intentional (e.g., vocabulary drills, pronunciation practice, emphasis). Do NOT deduplicate, merge, or skip repeated lines.
5. Do NOT over-split sentences into tiny fragments. Keep continuous speech by the same speaker as a SINGLE line unless the source explicitly contains a pause marker, emotion/tone shift, or speaker change. For example, a full paragraph spoken by one narrator should be ONE line, not broken into one line per sentence.

Content: ${content}

Specifications:
- Title: ${config.title}
- Audience: ${config.targetAudience}
- Format: ${config.formatAndDuration}
- Tone: ${config.toneAndExpression}
- Background Music: ${config.addBgm ? 'Yes' : 'No'}
- Sound Effects: ${config.addSoundEffects ? 'Yes' : 'No'}
- Visual Content: ${config.hasVisualContent ? 'Yes' : 'No'}

Generate a JSON ${config.addBgm ? 'object' : 'array of sections'}.${config.addBgm ? `
The top-level JSON object has two keys:
- "sections": the array of sections
- "bgmRecommendation": { "description": "...", "presetId": "..." }` : ''}

Each section has:
- id: unique identifier
- name: section name (e.g., "INTRO", "MAIN PART 1", "CONCLUSION") — use chapter titles/headers from the source here
- description: brief description of the section — incorporate any tone/style/stage directions from the source here
${visualInstruction}
- timeline: array of timeline items, each with:
  - id: unique identifier
  - timeStart: start time (e.g., "00:00")
  - timeEnd: end time (e.g., "00:15")
  - lines: array of speaker-line pairs, each with:
    - speaker: the character name (e.g., "Narrator", "Host", "Guest A")
    - line: ONLY actual spoken narrative/dialogue — never titles, headers, or stage directions
${soundInstruction}
${bgmRecommendationInstruction}

REMINDER: Each "line" must be something a voice actor would actually speak aloud. Titles, annotations, and directions belong in the section metadata, not in lines.

Return ONLY the JSON, no other text.`;
}

/**
 * Parse script generation response, handling both:
 * - Object format: { sections: [...], bgmRecommendation: {...} }
 * - Array format: [...]  (legacy, when addBgm is false)
 */
export function parseScriptGenerationResponse(text: string): {
  sections: unknown[];
  bgmRecommendation?: BgmRecommendation;
} {
  // Extract JSON from markdown code blocks or raw text
  const jsonMatch = text.match(/```(?:json)?\s*([\s\S]*?)```/);
  let jsonStr = jsonMatch ? (jsonMatch[1] || jsonMatch[0]).trim() : text.trim();

  // Try parsing as-is first
  let parsed: unknown;
  try {
    parsed = JSON.parse(jsonStr);
  } catch {
    // Fallback: try to find array or object pattern
    const objMatch = text.match(/\{[\s\S]*\}/);
    const arrMatch = text.match(/\[[\s\S]*\]/);
    jsonStr = (objMatch?.[0] || arrMatch?.[0] || jsonStr).trim();
    parsed = JSON.parse(jsonStr);
  }

  // Object format: { sections, bgmRecommendation }
  if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {
    const obj = parsed as Record<string, unknown>;
    if (Array.isArray(obj.sections)) {
      return {
        sections: obj.sections,
        bgmRecommendation: obj.bgmRecommendation as BgmRecommendation | undefined,
      };
    }
  }

  // Array format (legacy)
  if (Array.isArray(parsed)) {
    return { sections: parsed };
  }

  throw new Error('Invalid script generation response format');
}

/**
 * Character analysis result per character.
 */
export interface CharacterAnalysis {
  tags: string[];
  voiceDescription: string;
}

/**
 * Build a prompt to analyze characters from a generated script,
 * extracting tags and a TTS voice description for each character.
 * Returns a JSON object mapping character name → { tags, voiceDescription }.
 */
export function buildCharacterAnalysisPrompt(
  scriptJson: string,
  characterNames: string[],
  language: 'en' | 'zh' = 'en'
): string {
  const namesList = characterNames.map(n => `"${n}"`).join(', ');

  if (language === 'zh') {
    return `你是一个专业的配音导演。请根据以下脚本内容，分析每个Speaker角色的特征。

脚本内容（JSON 格式）:
${scriptJson}

需要分析的Speaker: [${namesList}]

为每个角色生成：
1. 2-4 个标签（tags），标签类型包括：
   - 性别（如：男性、女性）
   - 年龄段（如：儿童、青年、中年、老年）
   - 声音风格（如：温暖、低沉、活泼、严肃、专业、温柔）
   - 角色类型（如：主持人、旁白、嘉宾、叙述者）

2. 一段英文的声音描述（voiceDescription），约 50 个英文字符，用于 TTS 语音合成。必须用英文，包含以下方面：
   - Tone/Timbre/Pacing（如 "deep", "low-pitched", "speaks quickly", "smooth"）
   - Audio Quality（如 "studio-quality", "clear"）
   - Accent（如 "standard American accent", "British accent"）
   示例："Warm deep male voice, moderate pace, studio-quality, standard American accent"

以 JSON 对象格式返回，key 是角色名，value 是包含 tags 和 voiceDescription 的对象。示例：
{"主持人": {"tags": ["男性", "中年", "专业"], "voiceDescription": "Warm deep male voice, moderate pace, studio-quality"}, "嘉宾": {"tags": ["女性", "青年", "活泼"], "voiceDescription": "Bright young female voice, energetic pace, clear audio"}}

只输出 JSON，不要其他文字。`;
  }

  return `You are a professional voice director. Analyze the following podcast script and extract descriptive tags and a voice description for each character.

Script (JSON):
${scriptJson}

Characters to analyze: [${namesList}]

For each character, generate:
1. 2-4 tags. Tag categories include:
   - Gender (e.g. Male, Female)
   - Age group (e.g. Child, Young, Middle-aged, Elderly)
   - Voice style (e.g. Warm, Deep, Energetic, Serious, Professional, Gentle)
   - Role type (e.g. Host, Narrator, Guest, Storyteller)

2. A voiceDescription string (~50 characters, English only) for TTS voice synthesis. It should cover:
   - Tone/Timbre/Pacing (e.g. "deep", "low-pitched", "speaks quickly", "smooth")
   - Audio Quality (e.g. "studio-quality", "clear")
   - Accent (e.g. "standard American accent", "thick French accent")
   Example: "Warm deep male voice, moderate pace, studio-quality, standard American accent"

Return a JSON object where keys are character names and values are objects with "tags" and "voiceDescription". Example:
{"Host": {"tags": ["Male", "Middle-aged", "Professional"], "voiceDescription": "Warm deep male voice, moderate pace, studio-quality"}, "Guest": {"tags": ["Female", "Young", "Energetic"], "voiceDescription": "Bright young female voice, energetic pace, clear audio"}}

Return ONLY the JSON, no other text.`;
}
